# Garbage Collection

- garbage collection은 동적 할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법이다. 더 이상 사용할 수 없게 된 영역이란, 어떤 변수도 가리키지 않게 된 영역을 의미한다.

### 장점

- 프로그래머가 동적으로 할당한 메모리 영역의 전체를 완벽하게 관리할 필요 없다.
- 이중 해제 : 이미 해제된 메모리를 또 해제하는 버그
- 메모리 누수 : 더 이상 필요하지 않은 메모리가 해제되지 않고 남아있는 버그
- 유효하지 않는 포인트 접근 : 이미 해제된 메모리에 접근하는 버그
- 위 3가지의 버그를 줄이거나 막을 수 있습니다.

### 단점

- 어떤 메모리를 해제할지 결정하는 데 비용이 든다. 객체가 필요없어지는 시점을 프로그래머가 미리 알고 있는 경우에도 garbage Collection 알고리즘이 메모리 해제 시점을 추적해야 하므로, 이 작업은 오버헤드가 된다.
- garbage Collection이 일어나는 타이밍이나 점유 시간을 미리 예측하기 어렵다.
- 할당된 메모리가 해제되는 시점을 알 수 없다.

### 포인터 추적 방식

- 대부분의 garbage Collection 기법은 포인터 추적 방식을 사용한다.
- 포인터 추적 방식은 한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고, 그 밖의 메모리를 해제하는 방식을 가리킨다.

**접근 가능 객체**

- 접근 가능한 객체는 어떤 변수가 직접 가리키는 메모리, 또는 간접적으로 가리키는 메모리를 의미한다.

**여러가지 포인터 추적 기법**

1. 표시하고 쓸기(mark and sweep)
   1. 각 메모리 할당 영역에 표시를 위해 1 비트 메모리를 남긴다. (변수가 가리키면 사용중 표시)
   2. 표시되지 않은 영역인 접근 불가능 메모리 영역을 쓸기단계에서 모두 해제
   3. 단점은 표시 단계에서 메모리 내용이 변경되지 않아야 하기 때문에 전체 시스템 실행 정지. 또한, 전체 메모리 영역을 검사하므로 메모리 페이징을 사용하는 OS에서 프로그램 성능 저하
2. 삼색 표시 기법
   1. 표시하고 쓸기 기법의 단점을 보완
   2. 표시단계에서 2가지가 아닌 3가지(흰색, 회색, 검은색) 정보 중 하나로 표시
   3. 흰색은 더 이상 접근 불가능 한 객체
   4. 회색은 접근 가능한 객체, 이 객체에서 가리키는 객체들은 아직 검사하지 않았음
   5. 검은색은 이 영역에서 가리키는 객체들이 흰색 객체를 가리키지 않음을 의미
   6. 회색으로 표시된 객체 가운데 하나를 선택하여 검은색으로 표시, 이 객체가 가리키는 모든 객체를 회색으로 표시 ..... 반복
   7. 남은 흰색 객체는 접근 불가능한 객체이므로, 모두 해제
   8. 이 알고리즘은 단순한 표시하고 쓸기 알고리즘과 달리, 프로그램이 실행 중에도 병행하여 수행 가능 (주기적으로 수집하는 것도 가능)
3. 객체 이동 기법
   1. 객체 이동 기법은 해제할 객체 표시가 완료된 후 해제되지 않은 객체를 그래도 두는 것이 아니라, 다른 영역으로 복사하는 기법
   2. 해제된 후 재사용 가능한 영역과 사용 중인 영역을 표시하기 위해 추가적인 작업을 할 필요 없다. 따라서 해제된 영역을 포인터로 관리하는 방식이 비해 할당과 해제가 빠르다.
   3. 할당된 메모리들이 단편화되는 것을 막을 수 있다.
   4. 연결 리스트와 같은 연결형 자료구조에서, 서로 연결된 객체들이 메모리 상에서 가까운 위치에 할당될 확률이 높다. 이는 캐시와 관련하여 성능 향상에 도움
   5. 반면, 메모리 이동 기법은 주기적으로 포인터의 내용이 바뀌므로 포인터 연산 사용 불가
4. 세대 단위 쓰레기 수집
   1. 연구자들은 프로그램에서 새롭게 할당된 영역일수록 금방 해제될 확률이 높다는 관찰 보고
   2. 이런 특성을 이용하여 각 객체를 할당된 시간에 따라 세대별로 구별, 세대별로 다른 메모리 영역에 객체를 할당
   3. 한 세대의 메모리 영역이 꽉 차면, 이 메모리 영역에서 살아남은 객체를 더 오래된 메모리 영역으로 옮긴다.
   4. 새로 할당된 영역에서는 대부분의 객체들이 빠르게 해제되고 오래된 영역에서는 객체들이 변하지 않을 확률이 높으므로, 이 기법은 메모리의 일부 영역만을 주기적으로 수집하게 되는 장점이 있다.
   5. 자바 등 현대적 언어들은 대부분 이 기법을 사용

### 참조 횟수 계산 방식

- 일부 garbade Collection은 참조 횟수 계산 방식을 사용한다.
- 참조 횟수 계산 방식은 각 객체에서 참조 횟수를 기억하여, 참조 횟수가 0이 되면 해당 객체를 해제하는 방식을 가리킨다.

**장점**

- 객체가 접근 불가능해지는 즉시 메모리가 해제되므로, 프로그래머가 객체의 해제 시점을 어느정도 예측할 수 있다.
- 객체가 사용된 직후에 메모리를 해제하므로, 메모리 해제 시점에 해당 객체는 캐시에 저장되어 있을 확률이 높다. 따라서 메모리 해제가 빠르게 이루어진다.

**단점**

- 두 개 이상의 객체가 서로를 가리키고 있을 경우, 참조 횟수가 0이 되지 않게 된다. 순환참조라 하며 메모리 누수의 원인이다.
- 멀티쓰레드 환경에서는, 쓰레드 간에 공유하는 객체의 참조 횟수 계산을 위해 원자적 명령을 사용하거나 락을 걸어야한다. 이 문제를 회피하기 위해 스레드 단위 지역 변수로 참조 횟수를 따로 관리하면서, 스레드의 참조 횟수가 0이 될때만 전역 참조 횟수를 확인하는 방식을 사용할 수 있다. 리눅스 커널에서 이 방식을 사용한다.
- 참조 횟수가 0이 될때, 해당 객체가 가리키는 다른 객체들 또한 동시에 0으로 만드는 작업이 일어난다. 이 과정은 경우에 따라 많은 시간이 걸릴 수도 있기 때문에 실시간 시스템에는 적합하지 않을 수 있다.

https://ko.wikipedia.org/wiki/쓰레기_수집_(컴퓨터_과학)